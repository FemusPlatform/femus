// ===============================================================
// --------------   NAVIER-STOKES system [NS_F] ------------------
// ===============================================================
#include "Equations_conf.h"
#ifdef NS_EQUATIONS
// ==============================================================
// NS_EQUATIONS==0 projection solver (u,v,w) ( P in NSP_EQUATIONS)
// NS_EQUATIONS==1 coupled    solver (u,v,w,p)
// NS_EQUATIONS==2 segregated solver (u,v,w) ( P in NSP_EQUATIONS)
// ===============================================================
#if NS_EQUATIONS==1
// local Femus class include -----------------------------------
// class files --------------------------------------------------
#include "MGSclass_conf.h"        // Navier-Stokes class conf file
#include "MGSolverNS.h"       // Navier-Stokes class header file
#include "MGFE.h"          // Mesh class
#include <iomanip>      // std::setprecision

void MGSolNS::set_bc_matrix (
  DenseMatrixM &KeM, DenseVectorM &FeM,       ///< local Matrix and rhs
  int dir_maxnormal,                          ///<  normal dir
  int sur_toply[],                            ///< boundary topology map
  int el_ndof[],                              ///< number of volume dofs
  int elb_ndof[],                             ///< number of boundary dofs
  int elb_ngauss,                             ///<  number of surface gaussian points
  double normal[],                            ///< normal
  double u_old[],
  int el_conn[]
) {
  const double delta=_Wall_dist;
  double pressure;
  double vel_bound[1];
  double xyz_g[DIMENSION];
  const int elb_dof0= (NDOF_K>1) ?elb_ndof[_pres_order]*NDOF_K:elb_ndof[_pres_order];
  double det2= _fe[2]->JacSur (elb_ngauss-1,_xxb_qnds, _InvJac2); // jacobian
  double Ipenalty=det2;                            // Dirichlet bc flagdouble xyz_bg[DIMENSION];
  Ipenalty=1.e10;
  int integral=0;
  // Dirichlet

  const int bd_face = abs (_bc_bd[sur_toply[NDOF_FEMB-1]]) %100;
  const int norm_face = (abs (_bc_bd[sur_toply[NDOF_FEMB-1]]) %10000) /1000 -1 ;

  // TANGENT VECTORS BASED ON BOUNDARY GEOMETRY
  double dir_tang1[DIMENSION], dir_tang2[DIMENSION];
  CalcTangDir (dir_tang1, dir_tang2, normal, Geometrical);
  SetBCFlags (integral, normal, sur_toply, el_ndof[2],el_conn);

  if(bd_face == 88 || bd_face == 84){
     if (_FF_idx[K_F]>=0) {
       if(_NS_parameter._WallFunctionApproach == 1)  _WallElement = 1;
        for (int dir=0; dir<_nNSdim; dir++) _normal_pt[(NDOF_FEM -1)*_nNSdim+dir] += normal[dir];
    }      
  }
    
  // ...........................................................................................
  //     DIRICHLET BOUNDARY CONDITION
  // ...........................................................................................

  for (int  lbnode=0; lbnode<NDOF_FEMB; lbnode++) { 
    
    const int bd_node = abs (_bc_bd[sur_toply[lbnode]]) %100;
    const int bc_var_check2=abs (_bc_bd[sur_toply[lbnode]]);     // total  bc_var
    const int bc_var_npt= bc_var_check2/10000;              // recurrent  points in one element
    const int bc_var_check= bc_var_check2%10000;            // bc_var
    const int bc_var_normal= bc_var_check/1000 -1;          //
    const int bc_var=bc_var_check%1000;
    const int bc_n_flag=bc_var/10;
    const int bc_tg_flag=bc_var%10;
    
    if (_nNSdim == 3)  CorrectBCFlags (dir_tang1, dir_tang2, bc_var_normal, sur_toply[lbnode], el_ndof[2],0);

    
//     if(el_conn[sur_toply[lbnode]]==3) std::cout<<sur_toply[lbnode]<<
//       " "<<_bc_el[sur_toply[lbnode]]<<
//       " "<<_bc_el[sur_toply[lbnode] + el_ndof[2]]<<
//       " "<<_bc_el[sur_toply[lbnode] + 2*el_ndof[2]]<<
//       "\n -- node max normal " << bc_var_normal << " face max normal "<< norm_face <<" -- \n"<<
//       "\n -- node bc " << bd_node << " face bc "<< bd_face <<" -- \n"<<
//       " "<<normal[0]<<
//       " "<<normal[1]<<
//       " "<<normal[2]<<"\n"<<
//       " "<<dir_tang1[0]<<
//       " "<<dir_tang1[1]<<
//       " "<<dir_tang1[2]<<"\n"<<
//       " "<<dir_tang2[0]<<
//       " "<<dir_tang2[1]<<
//       " "<<dir_tang2[2]<<"\n"<<std::endl;
    if( bc_var == 44){
     double a=1.; 
    }
    if (bd_face==bd_node) {
      for (int row_shift=0; row_shift< _nvars[2]; row_shift++) { // LOOP OVER SPACE DIRECTIONS =======================================
        const int  indx_row=sur_toply[lbnode]+row_shift*el_ndof[2]; // solution indx

        bool NormBC = (abs (_bc_el[indx_row]) == 3) ? true : false;
        bool DirichletBC = (_bc_el[indx_row] > 0) ? true:false;

        if (DirichletBC /*!_AlreadyWrittenDirBC[indx_row]*/) {
//           _AlreadyWrittenDirBC[indx_row] = true;
          int  bc_bc  = NormBC? bc_n_flag : bc_tg_flag;
          const int  bc_rhs= ( (bc_bc%2) == 1) ? 1:0; // bc_rhs -> rhs bc
          bool OrDir = (bc_bc > 7) ? true:false;
          const double vart= bc_rhs*_data_eq[2].ub[indx_row+_FF_idx[NS_F]*el_ndof[2]];

          double alpha_beta = 1.;
          if (OrDir) {
            for (int   jvar=0; jvar< _nNSdim; jvar++)    { //  -beta_n*n*( u.n)
              const int indj=sur_toply[lbnode]+jvar*el_ndof[2];
              alpha_beta = -normal[jvar];
              if (!NormBC) alpha_beta = (_bc_el[indx_row] == 1) ? dir_tang1[jvar]:dir_tang2[jvar];
                KeM (indx_row,indj) += alpha_beta;
                FeM (indx_row) += _data_eq[2].ub[ (_FF_idx[NS_F]) *NDOF_FEM + indj]*bc_rhs*alpha_beta;	      
            }
          }
          else {              
            KeM (indx_row,indx_row) = alpha_beta;
            FeM (indx_row) = vart* alpha_beta;
          }// beta_0 u -> diagonal
        }
      }// END DIRICHLET BLOCK ====================================================================================
    }
  }


  // ...........................................................................................
  //     PRESSURE BOUNDARY CONDITION
  // ...........................................................................................

  const int bc_side_check2=_bc_bd[sur_toply[elb_ndof[2]-1]];  // total  bc_var
  const int bc_side_normal= (bc_side_check2%10000) /1000 -1;      //
  const int bc_side_n_flag= ( (bc_side_check2%10000) %1000) /10;

  if (bc_side_n_flag<4 && bc_side_n_flag>1) {
    const int  rhs_p=bc_side_n_flag%2;
    for (int i=0; i< elb_ndof[1]; i++) {
      if (_bc_bd[sur_toply[i]+DIMENSION*el_ndof[2]] ==4) { // the flag point is in this side
        const int   indx=_pres_order*sur_toply[i]+ _nNSdim*NDOF_FEM; // volume dof index
        _bc_el[indx]=0;                                                                                      // SET TO 1 -> CONTROL IF RIGHT
        KeM (indx,indx)  +=Ipenalty;
        FeM (indx)  +=  rhs_p*Ipenalty*_data_eq[_pres_order].ub[_pres_order*sur_toply[i]];
      }
    }
  }

  // ...........................................................................................
  //     INTEGRATION OVER BOUNDARY ELEMENT - STRESS CALCULATION
  // ...........................................................................................

  double dt=_dt;
  if (dt>1) dt=1. ;
  if (dt<1.e-10) dt=1.e-10;


  double tang1[DIMENSION], tang2[DIMENSION];
  CalcTangDir (tang1, tang2, normal, FlowAligned);

  for (int  qp=0; qp< elb_ngauss; qp++) { // START LOOP OVER GAUSS POINTS ===============================================
    double det   = _fe[2]->JacSur (qp,_xxb_qnds, _InvJac2);  // local coord _phi_g and jac
    double JxW_g = det*_fe[2]->_weight1[_nNSdim-2][qp]*dt;  // weight
    _fe[2]->get_phi_gl_g (_nNSdim-1,qp,_phi_g[2]);      // global coord _phi_g
    _fe[1]->get_phi_gl_g (_nNSdim-1,qp,_phi_g[1]);      // global coord _phi_g

    if (_AxiSym==1) {
      interp_el_bd_sol (_xx_qnds,sur_toply,el_ndof[2],0,_nNSdim,_phi_g[2],elb_ndof[2],_xyzg);
      JxW_g  *=_xyzg[0];    // axisymmetric  (index ->0)
    }
    double VelOnGauss[DIMENSION];
    interp_el_bd_sol (u_old,sur_toply,el_ndof[2],0,_nNSdim,_phi_g[2],elb_ndof[2],VelOnGauss);

    double u_tau, y_plus, eff_stress, VelOnBound, veltg;
    {// CALCULATION OF EFFECTIVE STRESS THROUGH U_TAU
         double unorm=0;  double utot=0;  
         for(int  kdim=0; kdim<_nNSdim; kdim++){ 
           unorm +=VelOnGauss[kdim]*normal[kdim];
           utot += VelOnGauss[kdim]*VelOnGauss[kdim];
         }
         const double WDist =_Wall_dist;// _mgutils._TurbParameters->_BoundWallDist;
         veltg  = sqrt(utot - unorm*unorm);
         u_tau      = 1.;//_mgutils._TurbParameters->CalcUtau(veltg + 1.e-10,WDist);

         y_plus     = WDist*u_tau/_IRe;
         eff_stress = (fabs(veltg) < 1.e-10)? _IRe/(WDist):u_tau*u_tau;
//          eff_stress = u_tau*u_tau;
         
	 VelOnBound = sqrt(utot);
     }
    
    
    for (int i=0; i< elb_ndof[2]; i++) { // LOOP OVER TEST FUNCTIONS ===================================================

      const int bc_var_check2=_bc_bd[sur_toply[i]];  // total  bc_var
      const int bc_var_npt= bc_var_check2/10000;                              // recurrent  points in one element

      const int sign = bc_var_check2/abs (bc_var_check2);

      const int bc_var_check= abs (_bc_bd[sur_toply[i]]) %10000;                          // bc_var
      const int bc_var_normal= bc_var_check/1000-1;                                 //
      const int bd_node = abs (_bc_bd[sur_toply[i]]) %100;
      const int bc_varn_flag=bd_node/10;
      const int bc_vartg_flag=bd_node%10;

      double phii_g  = _phi_g[2][i];

      if (bd_face==bd_node) {
	if(bd_face==44){
	  
	  
	   for (int  ivar=0; ivar< _nvars[2]; ivar++) { // LOOP OVER ROWS: i + row_shift*el_ndof2
          int indx_row     = sur_toply[i]+ivar*el_ndof[2];
	  
	     double lambda1=1.e+7;//_muf/(_rhof*1/*_Wall_dist*/);// linear zone;
	     double beta=lambda1*1.e+5;
//             const int  bc_rhs=((bc_vartg_flag%2)== 1)? 1:0;
//             const int   indx_row = sur_toply[i]+((bc_var_normal+1)%_nNSdim)*el_ndof[2];      // volume dof index
            const double dtJxW_g = JxW_g*(abs(_bc_el[indx_row])!=0? 1 :0);  // odd are non-homogeneus
    
//               int ivar=kivar%_nNSdim;
//               int alpha=1; int beta=0;  // no constraints on test function for orthogonal components
//               double alpha_beta = 1.;
//            for(int idim=0; idim< _nNSdim; idim++) {alpha_beta -= normal[ivar]*normal[idim]; }
              KeM(indx_row,sur_toply[i] + ivar*el_ndof[2]) +=  lambda1*dtJxW_g*_phi_g[2][i]*_phi_g[2][i];
//               FeM(indx_row) += bc_rhs*lambda*dtJxW_g*_phi_g[2][i];
//    for(int j=0; j<elb_ndof[2]; j++) {  // quad -quad -------------------------------------------------------
//            for(int idim=0; idim< _nNSdim; idim++)   
// 	     KeM(indx_row,sur_toply[j] + ivar*el_ndof[2]) -=  normal[ivar]*normal[idim]* lambda*dtJxW_g*_phi_g[2][j]*_phi_g[2][i];
//               } //  j
         for(int jvar=0; jvar<+_nNSdim; jvar++) {
              for(int j=0; j<elb_ndof[2]; j++) {  // quad -quad -------------------------------------------------------
		   KeM(indx_row,sur_toply[j] + ivar*el_ndof[2]) -=    normal[ivar]*normal[jvar]* lambda1*dtJxW_g*_phi_g[2][j]*_phi_g[2][i];
                 KeM(indx_row,sur_toply[j] + jvar*el_ndof[2]) +=   normal[jvar]*beta*dtJxW_g*_phi_g[2][j]*_phi_g[2][i];
              } //  j
            }// kivar
	 
	 
	   }
	 
	 
	 
	 
	}
	else{
	
        // DIRECTION OF MAXIMUM VECTOR COMPONENT OF TANGENT 1 AND 2 -> ALIGNMENT OF EQUATIONS
        if (_nNSdim == 3)  CorrectBCFlags (tang1, tang2, bc_var_normal, sur_toply[i], el_ndof[2],1);

        for (int  row_shift=0; row_shift< _nvars[2]; row_shift++) { // LOOP OVER ROWS: i + row_shift*el_ndof2
          int indx     = sur_toply[i]+row_shift*el_ndof[2];
          int NComp = (_bc_el[indx] < 0) ? _nNSdim:1;
          int bc_el = (_bc_el[indx]<=0) ? 1 :0;
          const double dtJxW_g =bc_el* JxW_g;

          bool NormBC = (_bc_el[indx] == -3) ? true : false;
          const int bc_flag = (NormBC) ? bd_node/10:bd_node%10;

          if (bc_flag > 1 && bc_flag<6) {
            // NORMAL VECTOR FOR THE PROJECTION OF VOLUME PART EQUATION
            if (qp==0) for (int dir=0; dir<_nNSdim; dir++) _normal_pt[ sur_toply[i]*_nNSdim+dir] += normal[dir];

            for (int  ivarN=row_shift; ivarN< row_shift+NComp; ivarN++) {// LOOP OVER VELOCITY COMPONENTS FOR EQUATION WRITTEN IN ROW indx
              const int ivar = ivarN%DIMENSION;
              double alpha_beta = 1.;

              if (_bc_el[indx]==-3) {// STRESS COMPONENT ALONG NORMAL DIRECTION
                alpha_beta = normal[ivar];
                if (bc_varn_flag < 4) { // Neumann normal bc_bc=2 o 3  ---------------------------------------------
                  double press=0.;
                  for (int j=0; j< elb_dof0; j++) {
                    press   += ( (1-_pres_order) +                   // piecewise pressure
                                 (_pres_order) *_phi_g[1][j]           // linear pressure
                               ) *_data_eq[_pres_order].ub[ (_FF_idx[NS_F]) *NDOF_FEM+_pres_order*sur_toply[j]];
// 		    KeM(indx, j+ _nNSdim*el_ndof[2]) += dtJxW_g*_phi_g[2][i]*_phi_g[1][j]*alpha_beta/**alpha_beta*/;
                  }
//                   FeM(indx)  += dtJxW_g*alpha_beta*_phi_g[2][i]*normal[ivar+_dir]*press;
                }
              }
              else if (_bc_el[indx] == -1 || _bc_el[indx] == -2) {// STRESS COMPONENT ALONG TANGENTIAL DIRECTIONS
                const int  bc_rhs= ( (bc_vartg_flag%2) == 1) ? 1:0;
                alpha_beta = (_bc_el[indx] == -1) ? tang1[ivar]:tang2[ivar];

                if (bc_flag==5) alpha_beta = tang1[ivar];

                double tau = (_bc_el[indx] == -1) ? sign*0.01:-0.01 ; //utau*utau/vel_bound;
                tau = eff_stress;
		
                double stress = alpha_beta*tau*dtJxW_g*_phi_g[2][i];
//                 FeM (indx) += bc_rhs*stress*VelOnGauss[ivar];
                for (int j=0; j<elb_ndof[2]; j++) {
                  KeM (indx,sur_toply[j] + ivar*el_ndof[2]) += -1.*stress*_phi_g[2][j];
                }// END LOOP OVER MATRIX COMPONENTS - IMPLICIT STRESS
              }// END LOOP IF EQUATION IS FOR TANGENTIAL DIRECTION
            }// END LOOP IF BC FLAG IS FOR INTEGRATION
          }// END LOOP OVER VARIABLES FOR LINEAR COMBINATION OF EQUATIONS
        }// END LOOP OVER MATRIX ROWS RELATIVE TO TEST FUNCTION I
      }// END IF BC_NODE == BC_FACE
  
      
//       if(bd_face==44){
// 	  
// 	  double aa=69;
	}
    }// END LOOP OVER BOUNDARY TEST FUNCTIONS =========================================================================
  }// END GAUSSIAN INTEGRATION ========================================================================================

  return;
}


void MGSolNS::SetBCFlags (int &integral, double normal[], int sur_toply[], int el_ndof, int el_conn[]) {
  const int bd_face = abs (_bc_bd[sur_toply[NDOF_FEMB-1]]) %100;
  const int norm_face = (abs (_bc_bd[sur_toply[NDOF_FEMB-1]]) %10000) /1000 -1 ;

  for (int  lbnode=0; lbnode<NDOF_FEMB; lbnode++) {
    const int bd_node = abs (_bc_bd[sur_toply[lbnode]]) %100;
    const int bc_var_check= abs (_bc_bd[sur_toply[lbnode]]) %10000;          // bc_var
    int bc_var_normal= bc_var_check/1000 -1;          //
    const int bc_n_flag= bd_node/10;
    const int bc_tg_flag=bd_node%10;

    bool Norm_Dirichlet_Bound_Cond = (bc_n_flag>5) ? true:false;
    bool Tang_Dirichlet_Bound_Cond = (bc_tg_flag>5) ? true:false;

    int NormDir = bc_var_normal;
    int DIrTg=0, NeuTg=0;

    if (bd_face==bd_node) {// BC ARE IMPOSED ONLY IF NODE BC EQUAL TO FACE BC
      int NormRow = sur_toply[lbnode]+NormDir*el_ndof;
      // SETTING BC FLAGS FOR NORMAL DIRECTION
      if (_bc_el[NormRow] == _BdFlagId) {
        if (Norm_Dirichlet_Bound_Cond) _bc_el[NormRow] = 3;
        else {
          integral=1;
          if (bc_n_flag==1) _bc_el[NormRow] = 0;
          else _bc_el[NormRow] = -3;
        }
      }

      for (int Tan= NormDir+1; Tan<NormDir+_nvars[2]; Tan ++) {// SETTING BC FLAGS FOR TANGENTIAL DIRECTIONS
        int TanShift = Tan%_nNSdim;
        int TanRow = sur_toply[lbnode]+TanShift*el_ndof;
        if (_bc_el[TanRow]==_BdFlagId) {
          if (Tang_Dirichlet_Bound_Cond) {// DIRICHLET BC
            DIrTg ++;
            _bc_el[TanRow] = DIrTg;
          }
          else {// NEUMANN BC
            if (bc_tg_flag==1) _bc_el[TanRow] = 0;
            else {
              NeuTg++;
              _bc_el[TanRow] = -NeuTg;
            }
            integral=1;
          }
        }
      }
    }
  }
  return;
}


void MGSolNS::CorrectBCFlags (double Tang1[],
                              double Tang2[],
                              int MaxNormal,
                              int ElementNode,
                              int ElDof,
                              int Dirichlet
                             )
{
  int tg1 = (MaxNormal+1) %DIMENSION;
  int tg2 = (MaxNormal+2) %DIMENSION;

  int tang1_maxdir = (fabs (Tang1[tg1]) > fabs (Tang1[tg2])) ? tg1:tg2;
  int tang2_maxdir = (fabs (Tang2[tg1]) > fabs (Tang2[tg2])) ? tg1:tg2;

  if (tang1_maxdir == tang2_maxdir) {
    int last_dir = (tang1_maxdir==tg1) ? tg2:tg1;
    if (fabs (Tang1[tang1_maxdir]) > fabs (Tang2[tang2_maxdir])) tang2_maxdir = last_dir;
    else tang1_maxdir = last_dir;
  }

  if (Dirichlet==1) {
    if (_bc_el[ElementNode+ (tg1) *ElDof]*_bc_el[ElementNode+  tg2 *ElDof] == 2
        && _bc_el[ElementNode+  tg1 *ElDof]+_bc_el[ElementNode+  tg2 *ElDof] == -3) {
      _bc_el[ElementNode+ (tang1_maxdir) *ElDof] = -1;
      _bc_el[ElementNode+ (tang2_maxdir) *ElDof] = -2;
    }
  }
  else if (Dirichlet==0) {
    if (_bc_el[ElementNode+ (tg1) *ElDof]*_bc_el[ElementNode+  tg2 *ElDof] == 2
        && _bc_el[ElementNode+  tg1 *ElDof]+_bc_el[ElementNode+  tg2 *ElDof] == 3) {
      _bc_el[ElementNode+ (tang1_maxdir) *ElDof] = 1;
      _bc_el[ElementNode+ (tang2_maxdir) *ElDof] = 2;
    }
  }

  return;
}



#endif




#endif


